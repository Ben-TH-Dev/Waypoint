package beh59.aber.ac.uk.cs39440.mmp.data.repository.impl

import android.util.Log
import beh59.aber.ac.uk.cs39440.mmp.data.models.Conversation
import beh59.aber.ac.uk.cs39440.mmp.data.models.Message
import beh59.aber.ac.uk.cs39440.mmp.data.models.states.ChatState
import beh59.aber.ac.uk.cs39440.mmp.data.repository.IChatRepository
import beh59.aber.ac.uk.cs39440.mmp.data.source.remote.ChatDataSource
import com.google.firebase.Timestamp
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.perf.metrics.AddTrace
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.withContext
import javax.inject.Inject

/**
 * ChatRepository
 * An implementation of the interface IChatRepository and its required methods.
 * Responsible for holding the data required by the chat systems of the application and
 * communicating with ChatDataSource
 * @param db The current instance of Firestore used by the application
 * @param chatDataSource Handles retrieval of messages and conversations
 * @property chatState Exposes ChatState and its data to the UI
 */
class ChatRepository @Inject constructor(
    private val db: FirebaseFirestore,
    private val chatDataSource: ChatDataSource
) : IChatRepository {
    private val _chatState = MutableStateFlow(ChatState())
    override val chatState: StateFlow<ChatState> = _chatState.asStateFlow()

    /**
     * createConversation
     * An implementation of createConversation that takes in a list of members and a title, and
     * writes a new conversation to Firestore. Conversations are essentially groups of members and
     * associated texts.
     * @param participants A list of UIDs belonging to the members of the conversation
     * @param title A textual title describing the conversation's purpose
     * @return The unique identifier of the new conversation and its document ID in Firestore
     */
    @AddTrace(name = "chatRepoCreateConversation")
    override suspend fun createConversation(participants: List<String>, title: String): String {
        return withContext(Dispatchers.IO) {
            try {
                val conversationData = hashMapOf(
                    "title" to title,
                    "createdAt" to Timestamp.now(),
                    "lastMessageContent" to "",
                    "lastMessageTimestamp" to Timestamp.now()
                )

                //Creates a new document in the conversations collection in Firestore with auto ID
                //as the document ID.
                val conversationReference = db.collection("conversations").document()
                //Stores the autogenerated document ID locally
                val conversationID = conversationReference.id

                //Runs in a transaction to prevent concurrency issues
                db.runTransaction { transaction ->
                    //Writes the conversation data hashmap to the location at conversationReference
                    transaction.set(conversationReference, conversationData)

                    //Writes member data to the seperate collection conversation-memberships which
                    //keeps track of who is part of what conversations. Passes each member's
                    ///userID as lambda
                    participants.forEach { userID ->
                        val membershipRef = db.collection("conversation-memberships").document()
                        transaction.set(
                            membershipRef, hashMapOf(
                                "uid" to userID,
                                "conversationID" to conversationID,
                                "role" to "member",
                                "dateJoined" to Timestamp.now()
                            )
                        )
                    }
                }.await()

                //Returns the unique identifier of the newly created conversation if everything is
                //successful
                conversationID
            } catch (e: Exception) {
                //Throws an exception in cases of failure
                Log.e("ChatRepository", "Error creating conversation", e)
                throw e
            }
        }
    }

    /**
     * sendMessage
     * Responsible for writing a text message to the database
     * @param message The text message to store in Firestore.
     * @return True if successfully written, false if not
     */
    @AddTrace(name = "chatRepoSendMessage")
    override suspend fun sendMessage(message: Message): Boolean {
        return withContext(Dispatchers.IO) {
            try {
                //Creates a hash map of the contents of the Message object to the Firestore document
                //fields
                val messageData = hashMapOf(
                    "messageID" to message.messageID,
                    "senderID" to message.senderID,
                    "receiverID" to message.receiverID,
                    "content" to message.content,
                    "timestamp" to message.timestamp,
                    "conversationID" to message.conversationID
                )

                //Writes a new document in the messages collection with the document ID being the
                //unique identifier of the message and the data in the messageData hashmap
                db.collection("messages")
                    .document(message.messageID)
                    .set(messageData)
                    .await()

                //Finds the relevant document in the conversations collection using the
                //conversationID field of the new message and updates the two fields for display
                //purposes on the ChatOverview screen
                db.collection("conversations")
                    .document(message.conversationID)
                    .update(
                        mapOf(
                            "lastMessageContent" to message.content,
                            "lastMessageTimestamp" to message.timestamp
                        )
                    ).await()

                //Returns true when all network calls have completed successfully, signalling
                //success
                true
            } catch (e: Exception) {
                //If there are any problems, logs the error and returns false, signalling failure
                Log.e("ChatRepository", "Error sending message", e)
                false
            }
        }
    }

    /**
     * loadConversations
     * Communicates with ChatDataSource to manually load conversations for a given user and update
     * state safely
     * @param userID The unique identifier of the user conversations are being loaded for
     */
    @AddTrace(name = "chatRepoLoadConversations")
    override suspend fun loadConversations(userID: String) {
        withContext(Dispatchers.IO) {
            //Updates the state to signal that we are loading whilst the network calls take place
            _chatState.value = _chatState.value.copy(isLoading = true)

            try {
                //Communicates with ChatDataSource to acquire a list of conversations the user is
                //involved in
                val conversations = chatDataSource.retrieveConversations(userID)

                //Updates state with the retrieved data and signals that the network call is
                //complete
                _chatState.value = _chatState.value.copy(
                    conversations = conversations,
                    isLoading = false
                )
            } catch (e: Exception) {
                //If there are any problems, logs the error and the state is updated to signal that
                //the network call is complete.
                Log.e("ChatRepository", "Error loading conversations", e)
                _chatState.value = _chatState.value.copy(
                    isLoading = false
                )
            }
        }
    }

    /**
     * loadMessages
     * Communicates with ChatDataSource to manually load messages for a given conversation and
     * updates state safely
     * @param conversationID The unique identifier of the conversation messages are being loaded for
     */
    @AddTrace(name = "chatRepoLoadMessages")
    override suspend fun loadMessages(conversationID: String) {
        withContext(Dispatchers.IO) {
            //Updates the state to signal that we are loading whilst the network calls take place
            _chatState.value = _chatState.value.copy(isLoading = true)

            try {
                //Communicates with ChatDataSource to retrieve a list of any messages associated
                //with the given conversationID
                val messages = chatDataSource.retrieveMessages(conversationID)

                //Updates state with the message data and to signal that the network call is
                //complete
                _chatState.value = _chatState.value.copy(
                    messages = messages,
                    isLoading = false
                )
            } catch (e: Exception) {
                //If there are any problems, logs the error and updates state to signal that the
                //network call is complete.
                Log.e("ChatRepository", "Error loading messages", e)
                _chatState.value = _chatState.value.copy(
                    isLoading = false
                )
            }
        }
    }

    /**
     * setCurrentConversation
     * Used to update the value of currentConversation in state which signals which conversation
     * the current user is viewing
     * @param conversation The conversation the current user is viewing
     */
    override fun setCurrentConversation(conversation: Conversation?) {
        _chatState.value = _chatState.value.copy(currentConversation = conversation)
    }

    /**
     * clearMessages
     * Clears the message data stored in state
     */
    override fun clearMessages() {
        _chatState.value = _chatState.value.copy(messages = emptyList())
    }

    /**
     * deleteConversation
     * Contains the logic required to delete all data associated with a specific conversation and
     * deletion of the conversation itself.
     * @param conversation The conversation to delete
     */
    override suspend fun deleteConversation(conversation: Conversation) {
        withContext(Dispatchers.IO) {
            try {
                //Finds all message documents that belong to the given conversation
                val messagesQuery = db.collection("messages")
                    .whereEqualTo("conversationID", conversation.conversationID)
                    .get()
                    .await()

                //Finds all conversation membership documents that belong to the given conversation
                val membershipsQuery = db.collection("conversation-memberships")
                    .whereEqualTo("conversationID", conversation.conversationID)
                    .get()
                    .await()

                //Creates an instance of WriteBatch, which allows us to efficiently and safely delete
                //groups of data in one atomic unit rather than one-by-one
                val batch = db.batch()

                //Iterates through each message document returned by the query
                for (message in messagesQuery.documents) {
                    //Orders the deletion of each message document
                    batch.delete(message.reference)
                }

                //Iterates through each membership document returned by the query
                for (members in membershipsQuery.documents) {
                    //Orders the deletion of each membership document
                    batch.delete(members.reference)
                }

                //Orders the deletion of the conversations document itself using its unique identifier
                //which is also the document ID.
                batch.delete(db.collection("conversations").document(conversation.conversationID))

                //Carries out each of its orders at once as an atomic unit rather than one-by-one.
                //Deletion will only ever take place if the entire unit is deleted. If there are any
                //problems, nothing will be deleted.
                batch.commit().await()

                //Creates a new list of conversations in memory sans the deleted conversation and
                //updates the state with the new list
                val updatedConversations = _chatState.value.conversations.filter {
                    it.conversationID != conversation.conversationID
                }
                _chatState.value = _chatState.value.copy(conversations = updatedConversations)
            } catch (e: Exception) {
                //If there are any problems, logs the error and throws an exception.
                Log.e("ChatRepository", "Error deleting conversation", e)
                throw e
            }
        }
    }

    /**
     * startMessageListener
     * Starts a real-time listener for messages in the specified conversation
     * This will automatically update the UI whenever new messages are received
     * @param conversationID The unique identifier of the conversation that is being listened to
     */
    override fun startMessageListener(conversationID: String) {
        //Communicates with chatDataSource to begin listening for messages in the given conversation
        chatDataSource.listenForMessages(conversationID) { messages ->
            _chatState.value = _chatState.value.copy(
                messages = messages,
                isLoading = false
            )
        }

        Log.d("ChatRepository", "Started real-time message listener")
    }
}